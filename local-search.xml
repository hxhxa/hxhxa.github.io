<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第十天——4.面向对象</title>
    <link href="/2021/02/24/%E7%AC%AC%E5%8D%81%E5%A4%A9%E2%80%94%E2%80%944-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/24/%E7%AC%AC%E5%8D%81%E5%A4%A9%E2%80%94%E2%80%944-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="理解万事万物皆对象"><a href="#理解万事万物皆对象" class="headerlink" title="理解万事万物皆对象"></a>理解万事万物皆对象</h1><p>1.在Java语言范畴中，都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构</p><p>2.涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java语言层面交互时，都体现为类、对象。</p><h1 id="六、匿名对象的使用"><a href="#六、匿名对象的使用" class="headerlink" title="六、匿名对象的使用"></a>六、匿名对象的使用</h1><p>1.理解</p><p>我们创造的对象，没有显式的赋给一个变量名。即为匿名对象</p><p>2.特征</p><p>匿名对象只能调用一次。</p><p>3.使用</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第九天——4.面向对象</title>
    <link href="/2021/02/18/%E7%AC%AC%E4%B9%9D%E5%A4%A9%E2%80%94%E2%80%944-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/18/%E7%AC%AC%E4%B9%9D%E5%A4%A9%E2%80%94%E2%80%944-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、学习面向对象的三条主线"><a href="#一、学习面向对象的三条主线" class="headerlink" title="一、学习面向对象的三条主线"></a>一、学习面向对象的三条主线</h1><h2 id="一）Java类及类的成员"><a href="#一）Java类及类的成员" class="headerlink" title="一）Java类及类的成员"></a>一）Java类及类的成员</h2><p>属性、方法、构造器；</p><p>代码块、内部类</p><h2 id="二）面向对象的三大特征"><a href="#二）面向对象的三大特征" class="headerlink" title="二）面向对象的三大特征"></a>二）面向对象的三大特征</h2><p>封装性、继承性、多态性、（抽象性）</p><h2 id="三）其他关键字"><a href="#三）其他关键字" class="headerlink" title="三）其他关键字"></a>三）其他关键字</h2><p>this、super、static、abstract、interface、package、import</p><p>“大处着眼，小处着手”</p><h1 id="二、面向对象的编程思想"><a href="#二、面向对象的编程思想" class="headerlink" title="二、面向对象的编程思想"></a>二、面向对象的编程思想</h1><h2 id="一）面向过程（pop–procedure-oriented-programming）与面向对象（oop–procedure-oriented-programming）"><a href="#一）面向过程（pop–procedure-oriented-programming）与面向对象（oop–procedure-oriented-programming）" class="headerlink" title="一）面向过程（pop–procedure oriented programming）与面向对象（oop–procedure oriented programming）"></a>一）面向过程（pop–procedure oriented programming）与面向对象（oop–procedure oriented programming）</h2><p>二者都是一种思想，面向对象是相对于面向过程而言的。</p><h3 id="1-面向过程"><a href="#1-面向过程" class="headerlink" title="1.面向过程"></a>1.面向过程</h3><p>面向过程，强调是功能行为，以函数为最小单位，考虑怎么做。</p><p>①打开冰箱，②抬起大象放进冰箱，③关闭冰箱门</p><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h2><p>面向对象，将功能封装进对象，强调了具备了功能的对象，以类/对象为最小单位，考虑谁来做。面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">人&#123;<br><br>​     打开（冰箱）&#123;<br><br>​                冰箱.开开（）；<br><br>​             &#125;<br><br>​    抬起（大象）<br><br>&#125;<br><br>冰箱&#123;<br><br>​        开开&#123;&#125;<br><br>&#125;<br><br>之类的<br></code></pre></td></tr></table></figure><h2 id="二）面向对下个的三大特征"><a href="#二）面向对下个的三大特征" class="headerlink" title="二）面向对下个的三大特征"></a>二）面向对下个的三大特征</h2><p>封装（Encapsulation）</p><p>继承（Interitance）</p><p>多态（Polymorphism）</p><h2 id="三）面向对象的思想概述"><a href="#三）面向对象的思想概述" class="headerlink" title="三）面向对象的思想概述"></a>三）面向对象的思想概述</h2><p>程序员从面向过程的执行者转化成了面向对象的指挥者</p><h3 id="2-面向对象分析方法分析问题的思想和步骤："><a href="#2-面向对象分析方法分析问题的思想和步骤：" class="headerlink" title="2.面向对象分析方法分析问题的思想和步骤："></a>2.面向对象分析方法分析问题的思想和步骤：</h3><p>1、根据问题需要、选择问题所针对的现实世界中的实体</p><p>2、把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义，及借助某种程序语言，把类构造成计算机能够识别和处理的书记结构。</p><p>3、将类实例化成计算机中的对象，对象是计算机世界中解决问题的最终工具。=有·</p><h1 id="三、面向对象的基本元素：类和对象"><a href="#三、面向对象的基本元素：类和对象" class="headerlink" title="三、面向对象的基本元素：类和对象"></a>三、面向对象的基本元素：类和对象</h1><h2 id="一）面向对象的思想概述"><a href="#一）面向对象的思想概述" class="headerlink" title="一）面向对象的思想概述"></a>一）面向对象的思想概述</h2><h3 id="1、类（Class）和对象（Object）是面向对象的核心概念"><a href="#1、类（Class）和对象（Object）是面向对象的核心概念" class="headerlink" title="1、类（Class）和对象（Object）是面向对象的核心概念"></a>1、类（Class）和对象（Object）是面向对象的核心概念</h3><p>1）类是一类事物的描述，是抽象的、概念上的意义</p><p>2）对象是实际存在的该类事物的每个个体，因而也称为实例（instance）</p><p>万事万物皆对象</p><h3 id="2、面向对象的思想概述"><a href="#2、面向对象的思想概述" class="headerlink" title="2、面向对象的思想概述"></a>2、面向对象的思想概述</h3><p>1.类 = 抽象概念的人；对象 = 实实在在的某个人；</p><p>2.面向对象程序设计的重点是类的设计</p><p>3.类的设计其实就是类成员的设计</p><h2 id="二）Java类及类的成员"><a href="#二）Java类及类的成员" class="headerlink" title="二）Java类及类的成员"></a>二）Java类及类的成员</h2><h3 id="1-Java代码的世界是由诸多个不同功能的类构成的。"><a href="#1-Java代码的世界是由诸多个不同功能的类构成的。" class="headerlink" title="1.Java代码的世界是由诸多个不同功能的类构成的。"></a>1.Java代码的世界是由诸多个不同功能的类构成的。</h3><h3 id="2-常见的类成员"><a href="#2-常见的类成员" class="headerlink" title="2.常见的类成员"></a>2.常见的类成员</h3><p>属性：对应类中的成员变量（field = 域 = 字段）</p><p>行为：对应类中的成员方法（方法 = 成员变量 = 函数 = method）</p><p>创建类的对象 = 类的实例化 = 实例化类</p><p>调用对象的结构：属性、方法</p><p>调用对象的属性：“对象.属性”</p><h3 id="3-类和对象的使用（面向对象思想的实例）"><a href="#3-类和对象的使用（面向对象思想的实例）" class="headerlink" title="3.类和对象的使用（面向对象思想的实例）"></a>3.类和对象的使用（面向对象思想的实例）</h3><p>1.创建类，设计类成员（是否具有生命力，是否强大）</p><p>2.创建类的对象</p><p>3.通过“对象.属性”或”对象.方法”调用对象的结构</p><h2 id="三）对象的创建和使用"><a href="#三）对象的创建和使用" class="headerlink" title="三）对象的创建和使用"></a>三）对象的创建和使用</h2><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）意味着：如果我们修改一个对象的属性值a，则不影响另外一个属性a的值</p><h1 id="四、类中属性的使用"><a href="#四、类中属性的使用" class="headerlink" title="四、类中属性的使用"></a>四、类中属性的使用</h1><table><thead><tr><th></th><th>属性（成员变量）</th><th>局部变量</th></tr></thead><tbody><tr><td>不同点</td><td></td><td></td></tr><tr><td>在类中声明的位置的不同</td><td>直接定义在类的一对{}内</td><td>声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</td></tr><tr><td>关于权限修饰符</td><td>可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省、protected（封装性）。目前，声明属性时，都使用缺省就可以了。</td><td>不可以使用权限修饰</td></tr><tr><td>默认初始化值的情况</td><td>类的属性根据其类型，都有默认化初始值。整型（byte、short、int）=0；浮点型（float、double）=0.0；字符型（char）0或\u000;布尔型（boolean）false；引用数据类型（类、接口、数组）null</td><td>没有默认初始值。意味着在调用局部变量之前，一定要显式赋值。特别地，形参在调用时，我们赋值即可</td></tr><tr><td>在内存中加载位置</td><td>加载到堆空间中（非static）</td><td>加载到栈空间</td></tr><tr><td>相同点</td><td>1.定义变量的格式一样：数据类型  变量名 = 变量值</td><td></td></tr><tr><td></td><td>2.先声明，后使用</td><td></td></tr><tr><td></td><td>3.变量都有其对应的作用域</td><td></td></tr></tbody></table><h1 id="五、类中方法的声明和使用"><a href="#五、类中方法的声明和使用" class="headerlink" title="五、类中方法的声明和使用"></a>五、类中方法的声明和使用</h1><h2 id="一）方法"><a href="#一）方法" class="headerlink" title="一）方法"></a>一）方法</h2><p>描述类应该具有的功能</p><p>比如：math类：sqrt（）；random（）。。。。</p><p>scanner类：nextxxx（）。。。。</p><p>arrays类：sort（）。。。。</p><h3 id="1-举例"><a href="#1-举例" class="headerlink" title="1.举例"></a>1.举例</h3><p>public void eat( ) { }</p><p>public void sleep(int hour) { }</p><p>public String getName( ) { }</p><p>public String getNation(String nation) { }</p><h3 id="2-方法的声明"><a href="#2-方法的声明" class="headerlink" title="2.方法的声明"></a>2.方法的声明</h3><p>权限修饰符 返回值类型 方法名（形参列表）{</p><p>​       方法体</p><p>}</p><p>static、fianal、abstract来修饰的方法除外</p><h3 id="3-说明"><a href="#3-说明" class="headerlink" title="3.说明"></a>3.说明</h3><h4 id="1）关于权限修饰符"><a href="#1）关于权限修饰符" class="headerlink" title="1）关于权限修饰符"></a>1）关于权限修饰符</h4><p>（默认权限先都使用public）</p><p>Java规定的4种权限修饰符：private、public、缺省、protected（封装性详细讲）</p><h4 id="2）返回值类型（有返回值-没有返回值）"><a href="#2）返回值类型（有返回值-没有返回值）" class="headerlink" title="2）返回值类型（有返回值/没有返回值）"></a>2）返回值类型（有返回值/没有返回值）</h4><p>1.如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中需要使用return关键字来返回指定类型的变量或常量。</p><p>如果方法没有返回值，则声明方法时，用void来表示。通常，没有返回值的方法中，不使用return。如果使用return，则表示结束此方法。只能使用“return；”</p><p>2.我们定义方法该不该用返回值</p><p>看经验</p><p>题目要求</p><h4 id="3）方法名"><a href="#3）方法名" class="headerlink" title="3）方法名"></a>3）方法名</h4><p>属于标识符，遵循标识符的规则和规范，“见名知意”</p><h4 id="4）形参列表"><a href="#4）形参列表" class="headerlink" title="4）形参列表"></a>4）形参列表</h4><p>方法可以声明0个，1个或多个形参</p><p>格式：数据结构1  形参1，数据类型2  形参2，。。。。。。</p><p>问：我们定义方法时，是否定形参</p><p>答：题目要求；具体问题具体分析</p><h4 id="5）方法体"><a href="#5）方法体" class="headerlink" title="5）方法体"></a>5）方法体</h4><p>方法功能的体现</p><h3 id="4-return关键字的使用"><a href="#4-return关键字的使用" class="headerlink" title="4.return关键字的使用"></a>4.return关键字的使用</h3><h4 id="1）使用范围"><a href="#1）使用范围" class="headerlink" title="1）使用范围"></a>1）使用范围</h4><p>使用在方法体中</p><h4 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h4><p>结束方法；</p><p>针对于有返回值类型的方法，使用“return  数据”方法返回所要的数据；</p><h4 id="3）注意点"><a href="#3）注意点" class="headerlink" title="3）注意点"></a>3）注意点</h4><p>return关键字后面不可以声明执行语句。</p><h3 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h3><p>方法的使用中，可以调用当前类的属性或方法</p><p>特殊的：方法A中又调用了A：递归方法。</p><p>不可以在方法中定义方法。</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八天——3.数组</title>
    <link href="/2021/02/14/%E7%AC%AC%E5%85%AB%E5%A4%A9%E2%80%94%E2%80%943-%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/14/%E7%AC%AC%E5%85%AB%E5%A4%A9%E2%80%94%E2%80%943-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="四、数组中涉及的常见算法"><a href="#四、数组中涉及的常见算法" class="headerlink" title="四、数组中涉及的常见算法"></a>四、数组中涉及的常见算法</h1><h2 id="一）数组元素的赋值（杨辉三角、回形数）"><a href="#一）数组元素的赋值（杨辉三角、回形数）" class="headerlink" title="一）数组元素的赋值（杨辉三角、回形数）"></a>一）数组元素的赋值（杨辉三角、回形数）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时要求元素的值各不相同</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrPratice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-comment">// [0,1) [0,30) [1,31)</span><br>            arr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">30</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[i] == arr[j]) &#123;<br>                    i--;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二）求数值型数组中元素的最大值、最小值、平均数、总和等"><a href="#二）求数值型数组中元素的最大值、最小值、平均数、总和等" class="headerlink" title="二）求数值型数组中元素的最大值、最小值、平均数、总和等"></a>二）求数值型数组中元素的最大值、最小值、平均数、总和等</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//求数组中的最大值、最小值、平均数、总和等</span><br><span class="hljs-comment">//定义一个int型的一维数组，包含十个元素，分别赋一些随机整数，然后求出所有元素的最大值、最小值、和值、平均值并输出。要求所有随机数都是两位数。【【【</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">max</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> [] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>            arr[i] = (<span class="hljs-keyword">int</span>) (Math.random() * (<span class="hljs-number">99</span> - <span class="hljs-number">10</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//求数组的最大值</span><br>        <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; arr[i])&#123;<br>                maxValue = arr[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最大值为&quot;</span> + maxValue);<br>        <span class="hljs-comment">//求数组的最小值</span><br><br>        <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; arr.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(minValue &gt; arr[i])&#123;<br>                minValue = arr[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最小值为：&quot;</span> + minValue);<br>        <span class="hljs-comment">//求数组的和</span><br><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>            sum += arr[i];<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;总和为：&quot;</span> + sum);<br><br><br>        <span class="hljs-comment">//求数组的平均分</span><br>        <span class="hljs-keyword">int</span> avgValue = sum / arr.length;<br>        System.out.println(<span class="hljs-string">&quot;平均数为：&quot;</span> + avgValue);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三）数组的复制、反转、查找（线性查找、二分查找法）"><a href="#三）数组的复制、反转、查找（线性查找、二分查找法）" class="headerlink" title="三）数组的复制、反转、查找（线性查找、二分查找法）"></a>三）数组的复制、反转、查找（线性查找、二分查找法）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用简单数组</span><br><span class="hljs-comment">1.创建一个名为arrytest的类，在main（）方法中声明arry1和arry2两个变量，他们是int[]类型的数组</span><br><span class="hljs-comment">2.使用大括号&#123;&#125;，把arr1初始化为8个素数：2，3，5，7，11，13，17，19</span><br><span class="hljs-comment">3.显示arr1的内容</span><br><span class="hljs-comment">赋值arr2变量等于arr2中的偶索引元素，使其等于索引值（如arry[0]=0;arry[2]=2）,打印出arry1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">arr</span> &#123;<br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args)&#123;<br>        <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">array</span>1,<span class="hljs-built_in">array</span>2;<br>        <br>        <span class="hljs-built_in">array</span>1 = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>&#125;;<br>        <br>        <span class="hljs-comment">//显示arry1的内容</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">array</span>1.length;i++)&#123;<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-built_in">array</span>1[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">//赋值arr2变量等于arr1</span><br>        <span class="hljs-built_in">array</span>2 = <span class="hljs-built_in">array</span>1;<br>        <br>        <span class="hljs-comment">//修改arry2中的偶索引元素，使其等于索引值（如array【0】=0，array【2】=2）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">array</span>2.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">array</span>2[i] = i;<br>            &#125;<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println();<br>        <span class="hljs-comment">//打印array1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;<span class="hljs-built_in">array</span>1.length;i++)&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">array</span>1[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：2    3    5    7    11    13    17    19<br>                   0    3    2    7     4      13    6      19    </p><p>只把arr1的地址给了arr2；即两个变量地址值一样，都指向了堆空间的唯一的一个数组实体。</p><p>arr2 = arr1不能叫做数组的复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//赋值arr2变量等于arr1</span><br><span class="hljs-comment">//array2 = array1;(不是赋值)</span><br><span class="hljs-comment">//数组的复制</span><br>array2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[array1.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; array2.length;i++)&#123;<br>    array2[i] = array1[i];<br>&#125;<br><br><br><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">5</span><span class="hljs-number">7</span><span class="hljs-number">11</span><span class="hljs-number">13</span><span class="hljs-number">17</span><span class="hljs-number">19</span><br><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">5</span><span class="hljs-number">7</span><span class="hljs-number">11</span><span class="hljs-number">13</span><span class="hljs-number">17</span><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><h3 id="数组的反转"><a href="#数组的反转" class="headerlink" title="数组的反转"></a>数组的反转</h3><p>数组的赋值和复制，区别于数组变量的赋值（arr1=arr）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">arryfanzhuan</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><br>        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;JJ&quot;</span>,<span class="hljs-string">&quot;DD&quot;</span>,<span class="hljs-string">&quot;MM&quot;</span>,<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-string">&quot;GG&quot;</span>,<span class="hljs-string">&quot;AA&quot;</span>&#125;;<br><br>        <span class="hljs-comment">//数组的复制</span><br>        String[] arr1 = <span class="hljs-keyword">new</span> String[arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr1.length;i++)&#123;<br>            arr1[i] = arr[i];<br>        &#125;<br><br>        <span class="hljs-comment">//数组的反转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>            String temp = arr[i];<br>            arr[i] = arr[arr.length - i - <span class="hljs-number">1</span>];<br>            arr[arr.length -i -<span class="hljs-number">1</span>] =temp;<br>        &#125;<br><br>        <span class="hljs-comment">//方法2</span><br>        <span class="hljs-comment">//for (int i = 0,j = arr.length- 1;i &lt; j;i++,j--)&#123;</span><br>          <span class="hljs-comment">//  String temp = arr[i];</span><br>            <span class="hljs-comment">//arr[i] = arr[j];</span><br>            <span class="hljs-comment">//arr[j] = temp; </span><br>        <span class="hljs-comment">//&#125;</span><br>        <br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组的查找"><a href="#数组的查找" class="headerlink" title="数组的查找"></a>数组的查找</h3><p>线性查找（for循环）</p><p>折半查找/二分法查找（前提是有序）</p><h2 id="四）数组元素的排序方法"><a href="#四）数组元素的排序方法" class="headerlink" title="四）数组元素的排序方法"></a>四）数组元素的排序方法</h2><p>排序的目的是快速查找</p><p>时间复杂度，空间复杂度，稳定性</p><p>选择排序 （直接选择排序、堆排序）</p><p>交换排序（冒泡排序、快速排序）</p><p>插入排序（直接插入排序、折半插入排序、shell排序）</p><p>归并排序</p><p>桶式排序</p><p>基数排序</p><h1 id="五、arrays工具类的使用"><a href="#五、arrays工具类的使用" class="headerlink" title="五、arrays工具类的使用"></a>五、arrays工具类的使用</h1><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。</p><table><thead><tr><th align="center">boolean equals（int[ ] a, int [ ] b）</th><th align="center">判断两个数组是否相等</th></tr></thead><tbody><tr><td align="center">String toString(int[] a)</td><td align="center">输出数组信息</td></tr><tr><td align="center">void fill(int[] a,int val)</td><td align="center">将指定值填充到数组之中</td></tr><tr><td align="center">void sort(int[] a)</td><td align="center">对数组进行排序</td></tr><tr><td align="center">int binarySearch(int[] a,int key)</td><td align="center">对排序后的数组进行二分法检索指定的值</td></tr></tbody></table><h2 id="六、数组使用当中常见异常"><a href="#六、数组使用当中常见异常" class="headerlink" title="六、数组使用当中常见异常"></a>六、数组使用当中常见异常</h2>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七天——3.数组</title>
    <link href="/2021/02/12/%E7%AC%AC%E4%B8%83%E5%A4%A9%E2%80%94%E2%80%943-%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/12/%E7%AC%AC%E4%B8%83%E5%A4%A9%E2%80%94%E2%80%943-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、数组的概述"><a href="#一、数组的概述" class="headerlink" title="一、数组的概述"></a>一、数组的概述</h1><h2 id="一）数组"><a href="#一）数组" class="headerlink" title="一）数组"></a>一）数组</h2><p>是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p><h2 id="二）数组的要素（相关概念）"><a href="#二）数组的要素（相关概念）" class="headerlink" title="二）数组的要素（相关概念）"></a>二）数组的要素（相关概念）</h2><p>数组名</p><p>元素</p><p>角标、下标、索引</p><p>数组的长度：元素的个数 </p><h2 id="三）数组的特点"><a href="#三）数组的特点" class="headerlink" title="三）数组的特点"></a>三）数组的特点</h2><p>1.数组是有序的排列。</p><p>2.数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型。</p><p>3.创建数组对象会在内存中开辟一整块连续的空间。</p><p>4.数组的长度一旦确定，就不能修改。</p><h2 id="四）数组的分类"><a href="#四）数组的分类" class="headerlink" title="四）数组的分类"></a>四）数组的分类</h2><p>1.按照维数：一维数组、二维数组…….</p><p>2.按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</p><h1 id="二、一维数组的使用"><a href="#二、一维数组的使用" class="headerlink" title="二、一维数组的使用"></a>二、一维数组的使用</h1><h2 id="一）一维数组的声明和初始化"><a href="#一）一维数组的声明和初始化" class="headerlink" title="一）一维数组的声明和初始化"></a>一）一维数组的声明和初始化</h2><h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1.声明"></a>1.声明</h3><p>int [ ]    a；</p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><h4 id="1）静态初始化"><a href="#1）静态初始化" class="headerlink" title="1）静态初始化"></a>1）静态初始化</h4><p>数组的初始化和数组元素赋值操作同时进行</p><p>ida = new int[]{1001,1002,1003};</p><h4 id="2）动态初始化"><a href="#2）动态初始化" class="headerlink" title="2）动态初始化"></a>2）动态初始化</h4><p>数组的初始化和数组元素的赋值操作分开进行</p><p>string[ ] names = new string[5];</p><h4 id="3）错误写法"><a href="#3）错误写法" class="headerlink" title="3）错误写法"></a>3）错误写法</h4><p>int[ ] arr1 = new int[];</p><p>int [5] arr2 = new int[5];</p><p>int[ ] arr3 = new int[3] {1,2,3};</p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4)总结"></a>4)总结</h4><p>数组一旦初始化，其长度就确定了。</p><p>int[ ]  arr4 = {1,2,3,4,5};     也是正确的，属于类型推断</p><h2 id="二）如何调用数组的指定位置的元素"><a href="#二）如何调用数组的指定位置的元素" class="headerlink" title="二）如何调用数组的指定位置的元素"></a>二）如何调用数组的指定位置的元素</h2><p>通过角标的方式调用</p><p>数组的角标（或索引）从0开始，到数组长度-1结束。</p><p>【不是与数据库相关的交互功能，从0开始】</p><h2 id="三）如何获取数组的长度"><a href="#三）如何获取数组的长度" class="headerlink" title="三）如何获取数组的长度"></a>三）如何获取数组的长度</h2><p>属性：length属性</p><p>arr1.length</p><h2 id="四）如何遍历数组"><a href="#四）如何遍历数组" class="headerlink" title="四）如何遍历数组"></a>四）如何遍历数组</h2><p>使用循环结构进行遍历</p><h2 id="五）数组元素的默认初始化值（属性的默认初始化值也一样）"><a href="#五）数组元素的默认初始化值（属性的默认初始化值也一样）" class="headerlink" title="五）数组元素的默认初始化值（属性的默认初始化值也一样）"></a>五）数组元素的默认初始化值（属性的默认初始化值也一样）</h2><p>数组元素是整型，默认值都是0；</p><p>数组元素是浮点型，默认值都是0.0；</p><p>数组元素是char型，默认值都是0（是ASII 码的 0）或\ u 0 0 0；</p><p>数组元素是 B o o lean 型，默认值是false（ fa lse二进制用0表示 ）；</p><p>数组元素是引用数据类型时，默认值是 n u l l ；</p><h2 id="六）数组的内存解析"><a href="#六）数组的内存解析" class="headerlink" title="六）数组的内存解析"></a>六）数组的内存解析</h2><p>多数组嵌套，一组记录地址作为索引，记录地址</p><h1 id="三、多维数组的使用"><a href="#三、多维数组的使用" class="headerlink" title="三、多维数组的使用"></a>三、多维数组的使用</h1><h2 id="一-理解"><a href="#一-理解" class="headerlink" title="一)理解"></a>一)理解</h2><p>二维数组=表格（近似的等于）=由数组构成的数组。把一个数组作为另外一个数组的元素出现。</p><p>从数组底层的运行机制来看，其实没有多维数组。</p><h2 id="二）二维数组的声明和初始化"><a href="#二）二维数组的声明和初始化" class="headerlink" title="二）二维数组的声明和初始化"></a>二）二维数组的声明和初始化</h2><p>int[ ] [ ]   arr1 = new int [ ] [ ] { {1} , {2} , {3} };    静态初始化</p><p>String [ ] [ ]  arr2 =  new String[3] [2];  动态初始化1</p><p>String [ ] [ ]   arr3 =  new  String[3] [2]   动态初始化2</p><p>错误初始化</p><p>String [ ] [ ]   arr3 =  new  String[ ] [2]</p><p>String [4] [3]   arr3 =  new  String[ ] [ ]</p><p>也是正确的</p><p>int[ ]  arr4[ ] = new int[ ] [ ] { {1,2,3} , {4,5} , {6,7,8} };</p><p>int[ ]  arr5[ ] = { {1,2,3} , {4,5} , {6,7,8} }；</p><h2 id="三）如何调用数组的指定位置的元素"><a href="#三）如何调用数组的指定位置的元素" class="headerlink" title="三）如何调用数组的指定位置的元素"></a>三）如何调用数组的指定位置的元素</h2><p>arr3[1] = new String[4];     给arr3的第二个数组赋值一个Strinng数组。</p><p>arr[2] [4];      第三行第五列；</p><h2 id="四）如何获取数组的长度"><a href="#四）如何获取数组的长度" class="headerlink" title="四）如何获取数组的长度"></a>四）如何获取数组的长度</h2><p>数组的长度，和最后拆开的个数没有关系，和行数有关系，即第一层的元素个数（此时的元素个数也有可能是数组）。</p><h2 id="五）如何遍历数组"><a href="#五）如何遍历数组" class="headerlink" title="五）如何遍历数组"></a>五）如何遍历数组</h2><p>循环结构（2层嵌套循环）</p><p>for(int i=0;i&lt;arr.length;i++) {</p><p>​       for(int j=0;j&lt;arr[i].length;++) {</p><p>​       }</p><p>}</p><h2 id="六）数组元素的默认初始化值"><a href="#六）数组元素的默认初始化值" class="headerlink" title="六）数组元素的默认初始化值"></a>六）数组元素的默认初始化值</h2><p>规定：二维数组分为外层数组的元素，内层数组的元素。</p><p>外层元素：arr[0] ;    arr[5] ;        输出为地址值</p><p>内层元素：arr[3] [5] ;      与一维数组初始化值相同</p><table><thead><tr><th>初始化方式</th><th>int[] []   arr = new int [4] [2]</th><th>int [ ] [ ] = new int [4] [ ]</th></tr></thead><tbody><tr><td>外层元素arr[0]</td><td>地址值</td><td>null</td></tr><tr><td>内层元素arr[1] [2]</td><td>与一维数组初始化情况相同</td><td>不能调用，否则报错</td></tr></tbody></table><h2 id="七）数组的内存解析"><a href="#七）数组的内存解析" class="headerlink" title="七）数组的内存解析"></a>七）数组的内存解析</h2>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六天——2.Java基本语法</title>
    <link href="/2021/02/08/%E7%AC%AC%E5%85%AD%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/02/08/%E7%AC%AC%E5%85%AD%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="五）while循环"><a href="#五）while循环" class="headerlink" title="五）while循环"></a>五）while循环</h2><h3 id="1-循环结构的4个要素"><a href="#1-循环结构的4个要素" class="headerlink" title="1.循环结构的4个要素"></a>1.循环结构的4个要素</h3><p>1初始化条件</p><p>2循环条件（boolean类型）</p><p>3循环体</p><p>4迭代条件</p><h3 id="2-while结构"><a href="#2-while结构" class="headerlink" title="2.while结构"></a>2.while结构</h3><p>1初始化条件</p><p>while（2循环条件）{</p><p>​        3循环体；</p><p>​        <em>4迭代条件；</em></p><p>}</p><p>执行过程1-2-3-4-2-3-4———2</p><p>写while程序要注意4迭代条件，一旦丢了很可能造成死循环。我们写程序时要注意避免死循环。</p><p>for循环和while循环可以相互转换</p><p>for循环和while循环的初始化条件部分的作用范围不同</p><h2 id="六）do-while循环"><a href="#六）do-while循环" class="headerlink" title="六）do-while循环"></a>六）do-while循环</h2><h3 id="1-do-while循环结构"><a href="#1-do-while循环结构" class="headerlink" title="1.do-while循环结构"></a>1.do-while循环结构</h3><p>1初始化条件</p><p>do{</p><p>​         3循环体；</p><p>​         4迭代体；</p><p>}while（2循环条件）</p><h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h3><p>do-while循环至少会执行一次循环体</p><p>不在循环条件部分限制次数的结构：for（；；）或while（true）</p><p>结束循环的两种方式①循环条件部分返回false②在循环体中，执行break</p><h2 id="七）嵌套循环"><a href="#七）嵌套循环" class="headerlink" title="七）嵌套循环"></a>七）嵌套循环</h2><h3 id="1-嵌套循环"><a href="#1-嵌套循环" class="headerlink" title="1.嵌套循环"></a>1.嵌套循环</h3><p>将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环</p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>外层循环：循环结构B</p><p>内层循环：循环结构A</p><h3 id="3-说明"><a href="#3-说明" class="headerlink" title="3.说明"></a>3.说明</h3><p>内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</p><p>假设外层循环需要执行m次，内层循环需要执行n次，此时内层循环的循环体一共执行了m*n次</p><h3 id="4-技巧"><a href="#4-技巧" class="headerlink" title="4.技巧"></a>4.技巧</h3><p>外层循环控制行数，内层循环控制列数。</p><h2 id="八）特殊关键字的使用"><a href="#八）特殊关键字的使用" class="headerlink" title="八）特殊关键字的使用"></a>八）特殊关键字的使用</h2><h3 id="1-break"><a href="#1-break" class="headerlink" title="1.break"></a>1.break</h3><h4 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h4><p>switch-case</p><p>循环结构中</p><h4 id="在循环中的作用"><a href="#在循环中的作用" class="headerlink" title="在循环中的作用"></a>在循环中的作用</h4><p>结束当前循环</p><h3 id="2-continue"><a href="#2-continue" class="headerlink" title="2.continue"></a>2.continue</h3><h4 id="使用范围-1"><a href="#使用范围-1" class="headerlink" title="使用范围"></a>使用范围</h4><p>循环结构中</p><h4 id="在循环中的作用-1"><a href="#在循环中的作用-1" class="headerlink" title="在循环中的作用"></a>在循环中的作用</h4><p>结束单次循环</p><h3 id="3-相同点"><a href="#3-相同点" class="headerlink" title="3.相同点"></a>3.相同点</h3><p>关键字后面不能有执行声明语句</p><h3 id="4-附加"><a href="#4-附加" class="headerlink" title="4.附加"></a>4.附加</h3><h4 id="break-label"><a href="#break-label" class="headerlink" title="break label"></a>break label</h4><p>//指定标识的一层循环结束</p><h4 id="continue-label"><a href="#continue-label" class="headerlink" title="continue label"></a>continue label</h4><p>//指定标识的一层循环结构档次循环</p><h3 id="5-return的使用"><a href="#5-return的使用" class="headerlink" title="5.return的使用"></a>5.return的使用</h3><p>并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个return语句时，这个方法将被结束。</p><p>与break和continue不同的是，return是直接结束整个方法，不管这个return处于多少层循环之内。</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五天——2.Java基本语法</title>
    <link href="/2021/01/23/%E7%AC%AC%E4%BA%94%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/01/23/%E7%AC%AC%E4%BA%94%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="五、程序流程控制"><a href="#五、程序流程控制" class="headerlink" title="五、程序流程控制"></a>五、程序流程控制</h1><h2 id="一）if-else"><a href="#一）if-else" class="headerlink" title="一）if-else"></a>一）if-else</h2><h3 id="使用Scanner类具体实现步骤"><a href="#使用Scanner类具体实现步骤" class="headerlink" title="使用Scanner类具体实现步骤"></a>使用Scanner类具体实现步骤</h3><p>1.导包</p><p>import java.util.Scanner</p><p>2.scanner的实例化</p><p>Scanner scan = new Scanner(System.in)</p><p>3.调用scanner类的相关方法，来获取指定类型的变量</p><h3 id="获取不同类型的scanner类型（byte、boolen）"><a href="#获取不同类型的scanner类型（byte、boolen）" class="headerlink" title="获取不同类型的scanner类型（byte、boolen）"></a>获取不同类型的scanner类型（byte、boolen）</h3><p>string name = scan.next();</p><p>int age = scan.nextInt();</p><p>double weight = sacn.nextDouble();</p><p>boolean  isLove =  scan.nextBoolean();</p><p>//对于char型的获取，scanner没有提供相关的方法，只能获取一个字符串。</p><p>System.out.println(“请输入你的性别”);</p><p>String gender = scan.next();</p><p>char genederChar = gender.charAt();        //charat就是第几位就读取第几位的字符；以0为基准</p><p>注意：需要根据相应的方法来输入指定类型的值，如果输入类型和要求类型不匹配时，会报异常：InputMisMatchEXcel，程序终止。</p><h2 id="二）针对条件表达式"><a href="#二）针对条件表达式" class="headerlink" title="二）针对条件表达式"></a>二）针对条件表达式</h2><p>如果对于多个条件表达式之间是“互斥”关系（或没有交集的关系），哪个判断和执行语句声明在上面还是下面都不影响。</p><p>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将那个结构声明在上面。</p><p>如果多个条件表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面，否则，范围小的就没有机会声明</p><h2 id="三）switch-case结构"><a href="#三）switch-case结构" class="headerlink" title="三）switch-case结构"></a>三）switch-case结构</h2><h3 id="1-格式"><a href="#1-格式" class="headerlink" title="1.格式"></a>1.格式</h3><p>switch（表达式）{</p><p>case 常量1：</p><p>​        语句1；</p><p>​         //break；</p><p>case 常量2：</p><p>​        语句2；</p><p>​         //break；</p><p>………</p><p>case 常量n：</p><p>​        语句n；</p><p>​         //break；</p><p>default：</p><p>​        语句；</p><p>​         //break；</p><p>}</p><h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h3><p>1.根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句之后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或swith-case结构末尾结束为止。</p><p>2.break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。</p><p>3.switch结构中的表达式，只能是如下的六种数据类型之一：byte、short、char、int、枚举类型 、String类型。</p><p>4.case之后只能声明常量。不能声明范围</p><p>5.break的关键字是可选的。</p><p>6.default：相当于if-else结构中的else，default结构是可选的，而且位置是灵活的。</p><h3 id="3-switch-case和if-else的转换说明"><a href="#3-switch-case和if-else的转换说明" class="headerlink" title="3.switch-case和if-else的转换说明"></a>3.switch-case和if-else的转换说明</h3><p>凡是可以使用switch-case的结构，都可以转化为if-else。反之，不成立。</p><p>当我们写分支结构时，既可以使用switch-case（同时switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率高。</p><p>三元 和switch都可以转换成if，但是反之不成立。</p><h2 id="四）循环结构"><a href="#四）循环结构" class="headerlink" title="四）循环结构"></a>四）循环结构</h2><h3 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1.循环结构"></a>1.循环结构</h3><p>在某些条件满足的情况下。反复执行特定代码的功能。</p><h4 id="循环语句分类"><a href="#循环语句分类" class="headerlink" title="循环语句分类"></a>循环语句分类</h4><p>for循环</p><p>while循环 </p><p>do-while循环</p><h4 id="循环语句的四个组成部分"><a href="#循环语句的四个组成部分" class="headerlink" title="循环语句的四个组成部分"></a>循环语句的四个组成部分</h4><p>1初始化部分</p><p>2循环条件部分（是boolean类型）</p><p>3循环体部分</p><p>4迭代部分</p><h3 id="2-for循环结构的使用"><a href="#2-for循环结构的使用" class="headerlink" title="2.for循环结构的使用"></a>2.for循环结构的使用</h3><p>for（1初始化条件；2循环条件；4迭代条件）{</p><p>​       3循环体</p><p>}</p><p>执行过程：1-2-3-4-2-3-4-……..-2</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四天——2.Java基本语法</title>
    <link href="/2021/01/21/%E7%AC%AC%E5%9B%9B%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/01/21/%E7%AC%AC%E5%9B%9B%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><h2 id="一）分类"><a href="#一）分类" class="headerlink" title="一）分类"></a>一）分类</h2><p>算术运算符、赋值运算符、比较运算符（关系运算符）、逻辑运算符、位运算符、三元运算符</p><h2 id="二）算术运算符"><a href="#二）算术运算符" class="headerlink" title="二）算术运算符"></a>二）算术运算符</h2><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法 - 相加运算符两侧的值</td><td align="left">A + B 等于 30</td></tr><tr><td align="left">-</td><td align="left">减法 - 左操作数减去右操作数</td><td align="left">A – B 等于 -10</td></tr><tr><td align="left">*</td><td align="left">乘法 - 相乘操作符两侧的值</td><td align="left">A * B等于200</td></tr><tr><td align="left">/</td><td align="left">除法 - 左操作数除以右操作数</td><td align="left">B / A等于2</td></tr><tr><td align="left">％</td><td align="left">取余 - 左操作数除以右操作数的余数</td><td align="left">B%A等于0</td></tr><tr><td align="left">++（前）</td><td align="left">自增，先运算后取值</td><td align="left">B++ 或 ++B 等于 21（区别详见下文）</td></tr><tr><td align="left">++（后）</td><td align="left">自增，先取值后运算</td><td align="left"></td></tr><tr><td align="left">–（前）</td><td align="left">自减，先运算后取值</td><td align="left"></td></tr><tr><td align="left">–（后）</td><td align="left">自减:，先取值后运算</td><td align="left">B– 或 –B 等于 19（区别详见下文）</td></tr></tbody></table><h2 id="三）赋值运算符"><a href="#三）赋值运算符" class="headerlink" title="三）赋值运算符 ="></a>三）赋值运算符 =</h2><p>当“=”两侧数据类型不一致时，可以使用自动类型转换或者使用强制类型转换原则进行处理</p><p>支持连续赋值</p><p>int i = 10；int j = 10；</p><p>int i，j； i = j =10；</p><p>扩展赋值运算符：+=、-=、*=、/=、%=</p><p>n1 = 10；</p><p>n1 += （n1++） + （++n1）；//32</p><h2 id="四）比较运算符"><a href="#四）比较运算符" class="headerlink" title="四）比较运算符"></a>四）比较运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th><th>结果</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">（A == B）为假。</td><td>true/false</td></tr><tr><td align="left">!=</td><td align="left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td align="left">(A != B) 为真。</td><td></td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt; B）为假。</td><td></td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td align="left">（A &lt;B）为真。</td><td></td></tr><tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt; = B）为假。</td><td></td></tr><tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A &lt;= B）为真。</td><td></td></tr><tr><td align="left">instanceof</td><td align="left">该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</td><td align="left"></td><td></td></tr></tbody></table><h2 id="五）逻辑运算符"><a href="#五）逻辑运算符" class="headerlink" title="五）逻辑运算符"></a>五）逻辑运算符</h2><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td align="left">（A &amp;&amp; B）为假。</td></tr><tr><td align="left">| |</td><td align="left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td align="left">（A | | B）为真。</td></tr><tr><td align="left">！</td><td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td align="left">！（A &amp;&amp; B）为真。</td></tr></tbody></table><h3 id="amp-和-amp-amp"><a href="#amp-和-amp-amp" class="headerlink" title="&amp;和&amp;&amp;"></a>&amp;和&amp;&amp;</h3><p>相同点：运算结果相同；当符号左边是true时，二者都会执行符号右边的运算。</p><p>不同点：当符号左边是false时，&amp;继续执行符号右边的运算，&amp;&amp;不再执行符号右边的运算。</p><h3 id="和"><a href="#和" class="headerlink" title="|和||"></a>|和||</h3><p>相同点：运算结果相同；当符号左边是false时，二者都会执行符号右边的运算</p><p>不同点：当符号左边是true时，|继续执行符号右边的运算，||不再执行。</p><h2 id="六）位运算符"><a href="#六）位运算符" class="headerlink" title="六）位运算符"></a>六）位运算符</h2><p>位运算符是直接对整数的二进制进行的运算</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td><td align="left">（A＆B），得到12，即0000 1100</td></tr><tr><td align="left">|</td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td><td align="left">（A | B）得到61，即 0011 1101</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td><td align="left">（A ^ B）得到49，即 0011 0001</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td align="left">（〜A）得到-61，即1100 0011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td align="left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td align="left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><p>&lt;&lt;在一定范围内，每向左移一位，相当于*2</p><p>》》在一定范围内，每向右移动一位，相当于/2</p><h2 id="七）三元运算符"><a href="#七）三元运算符" class="headerlink" title="七）三元运算符"></a>七）三元运算符</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>（条件表达式）？表达式1：表达式2；</p><p>条件表达式1为true时，运算后结果表达式是1；若为false，运算后结果表达式是2；</p><p>表达式1和2为同种类型</p><h3 id="三元运算符与if-else的联系区别"><a href="#三元运算符与if-else的联系区别" class="headerlink" title="三元运算符与if-else的联系区别"></a>三元运算符与if-else的联系区别</h3><p>三元运算符可以简化if-else的语句</p><p>三元运算符要求必须返回一个结果</p><p>if后的代码块可以有多个语句</p><h3 id="三元运算符可以嵌套使用"><a href="#三元运算符可以嵌套使用" class="headerlink" title="三元运算符可以嵌套使用"></a>三元运算符可以嵌套使用</h3><h4 id="三元一定可以改写为if-else，反之不一定"><a href="#三元一定可以改写为if-else，反之不一定" class="headerlink" title="三元一定可以改写为if-else，反之不一定"></a>三元一定可以改写为if-else，反之不一定</h4><h2 id="八）运算符的优先级"><a href="#八）运算符的优先级" class="headerlink" title="八）运算符的优先级"></a>八）运算符的优先级</h2><p>只有单目运算符、三元运算符、赋值运算符是从右向左运算的。</p><table><thead><tr><th align="left">类别</th><th align="left">操作符</th><th align="left">关联性</th></tr></thead><tbody><tr><td align="left">后缀</td><td align="left">() [] . (点操作符)</td><td align="left">左到右</td></tr><tr><td align="left">一元</td><td align="left">expr++ expr–</td><td align="left">从左到右</td></tr><tr><td align="left">一元</td><td align="left">++expr –expr + - ～ ！</td><td align="left">从右到左</td></tr><tr><td align="left">乘性</td><td align="left">* /％</td><td align="left">左到右</td></tr><tr><td align="left">加性</td><td align="left">+ -</td><td align="left">左到右</td></tr><tr><td align="left">移位</td><td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td align="left">左到右</td></tr><tr><td align="left">关系</td><td align="left">&gt; &gt;= &lt; &lt;=</td><td align="left">左到右</td></tr><tr><td align="left">相等</td><td align="left">== !=</td><td align="left">左到右</td></tr><tr><td align="left">按位与</td><td align="left">＆</td><td align="left">左到右</td></tr><tr><td align="left">按位异或</td><td align="left">^</td><td align="left">左到右</td></tr><tr><td align="left">按位或</td><td align="left">|</td><td align="left">左到右</td></tr><tr><td align="left">逻辑与</td><td align="left">&amp;&amp;</td><td align="left">左到右</td></tr><tr><td align="left">逻辑或</td><td align="left">| |</td><td align="left">左到右</td></tr><tr><td align="left">条件</td><td align="left">？：</td><td align="left">从右到左</td></tr><tr><td align="left">赋值</td><td align="left">= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td><td align="left">从右到左</td></tr><tr><td align="left">逗号</td><td align="left">，</td><td align="left">左到右</td></tr></tbody></table><h1 id="五、程序流程控制"><a href="#五、程序流程控制" class="headerlink" title="五、程序流程控制"></a>五、程序流程控制</h1><p>顺序、分支、循环</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三天——2.Java基本语法</title>
    <link href="/2021/01/17/%E7%AC%AC%E4%B8%89%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/01/17/%E7%AC%AC%E4%B8%89%E5%A4%A9%E2%80%94%E2%80%942.Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、关键字和保留字"><a href="#一、关键字和保留字" class="headerlink" title="一、关键字和保留字"></a>一、关键字和保留字</h1><h2 id="一）关键字（keyword）"><a href="#一）关键字（keyword）" class="headerlink" title="一）关键字（keyword）"></a>一）关键字（keyword）</h2><p>1.赋予特殊含义，用作专门用途的字符串（单词）</p><p>2.关键字中所有字母都为小写</p><table><thead><tr><th align="center"><strong>关键字</strong></th><th align="left"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">abstract</td><td align="left">表明类或者成员方法具有抽象属性</td></tr><tr><td align="center">assert</td><td align="left">断言，用来进行程序调试</td></tr><tr><td align="center">boolean</td><td align="left">基本数据类型之一，声明布尔类型的关键字</td></tr><tr><td align="center">break</td><td align="left">提前跳出一个块</td></tr><tr><td align="center">byte</td><td align="left">基本数据类型之一，字节类型</td></tr><tr><td align="center">case</td><td align="left">用在switch语句之中，表示其中的一个分支</td></tr><tr><td align="center">catch</td><td align="left">用在异常处理中，用来捕捉异常</td></tr><tr><td align="center">char</td><td align="left">基本数据类型之一，字符类型</td></tr><tr><td align="center">class</td><td align="left">声明一个类</td></tr><tr><td align="center">const</td><td align="left">保留关键字，没有具体含义</td></tr><tr><td align="center">continue</td><td align="left">回到一个块的开始处</td></tr><tr><td align="center">default</td><td align="left">默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</td></tr><tr><td align="center">do</td><td align="left">用在do-while循环结构中</td></tr><tr><td align="center">double</td><td align="left">基本数据类型之一，双精度浮点数类型</td></tr><tr><td align="center">else</td><td align="left">用在条件语句中，表明当条件不成立时的分支</td></tr><tr><td align="center">enum</td><td align="left">枚举</td></tr><tr><td align="center">extends</td><td align="left">表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</td></tr><tr><td align="center">final</td><td align="left">用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td></tr><tr><td align="center">finally</td><td align="left">用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td></tr><tr><td align="center">float</td><td align="left">基本数据类型之一，单精度浮点数类型</td></tr><tr><td align="center">for</td><td align="left">一种循环结构的引导词</td></tr><tr><td align="center">goto</td><td align="left">保留关键字，没有具体含义</td></tr><tr><td align="center">if</td><td align="left">条件语句的引导词</td></tr><tr><td align="center">implements</td><td align="left">表明一个类实现了给定的接口</td></tr><tr><td align="center">import</td><td align="left">表明要访问指定的类或包</td></tr><tr><td align="center">instanceof</td><td align="left">用来测试一个对象是否是指定类型的实例对象</td></tr><tr><td align="center">int</td><td align="left">基本数据类型之一，整数类型</td></tr><tr><td align="center">interface</td><td align="left">接口</td></tr><tr><td align="center">long</td><td align="left">基本数据类型之一，长整数类型</td></tr><tr><td align="center">native</td><td align="left">用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td></tr><tr><td align="center">new</td><td align="left">用来创建新实例对象</td></tr><tr><td align="center">package</td><td align="left">包</td></tr><tr><td align="center">private</td><td align="left">一种访问控制方式：私用模式</td></tr><tr><td align="center">protected</td><td align="left">一种访问控制方式：保护模式</td></tr><tr><td align="center">public</td><td align="left">一种访问控制方式：共用模式</td></tr><tr><td align="center">return</td><td align="left">从成员方法中返回数据</td></tr><tr><td align="center">short</td><td align="left">基本数据类型之一,短整数类型</td></tr><tr><td align="center">static</td><td align="left">表明具有静态属性</td></tr><tr><td align="center">strictfp</td><td align="left">用来声明FP_strict（单精度或双精度浮点数）表达式遵循[IEEE 754](<a href="https://baike.baidu.com/item/IEEE">https://baike.baidu.com/item/IEEE</a> 754)算术规范</td></tr><tr><td align="center">super</td><td align="left">表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td align="center">switch</td><td align="left">分支语句结构的引导词</td></tr><tr><td align="center">synchronized</td><td align="left">表明一段代码需要同步执行</td></tr><tr><td align="center">this</td><td align="left">指向当前实例对象的引用</td></tr><tr><td align="center">throw</td><td align="left">抛出一个异常</td></tr><tr><td align="center">throws</td><td align="left">声明在当前定义的成员方法中所有需要抛出的异常</td></tr><tr><td align="center">transient</td><td align="left">声明不用序列化的成员域</td></tr><tr><td align="center">try</td><td align="left">尝试一个可能抛出异常的程序块</td></tr><tr><td align="center">void</td><td align="left">声明当前成员方法没有返回值</td></tr><tr><td align="center">volatile</td><td align="left">表明两个或者多个变量必须同步地发生变化</td></tr><tr><td align="center">while</td><td align="left">用在循环结构中</td></tr></tbody></table><h2 id="二）保留字（reserve-word）"><a href="#二）保留字（reserve-word）" class="headerlink" title="二）保留字（reserve word）"></a>二）保留字（reserve word）</h2><p>现有Java版本尚未使用，以后版本可能会作为关键字使用。</p><p>用自己命名标识符时要注意避开使用这些</p><h1 id="二、标识符identifier"><a href="#二、标识符identifier" class="headerlink" title="二、标识符identifier"></a>二、标识符identifier</h1><h2 id="一）标识符"><a href="#一）标识符" class="headerlink" title="一）标识符"></a>一）标识符</h2><p>Java对各种变量、方法、类等要素命名时使用的字符序列成为标识符</p><p>凡是可以自己起名的地方都叫标识符，比如，类名、变量名、方法名、接口名、包名</p><h2 id="二-标识符的规则"><a href="#二-标识符的规则" class="headerlink" title="二)标识符的规则"></a>二)标识符的规则</h2><ul><li>26个英文大小写，0-9，_，$</li><li>不能用数字开头</li><li>不能使用关键字和保留字，但是可以包含</li><li>严格区分大小写</li><li>不能包含空格</li></ul><h2 id="三）标识符命名规范"><a href="#三）标识符命名规范" class="headerlink" title="三）标识符命名规范"></a>三）标识符命名规范</h2><p>包名：多单词组成时所有字母小写</p><p>类名、接口名：多单词组成时所有单词的首字母大写</p><p>变量名、方法名：多字母组成时，第一个单词的首字母小写，第二个单词开始每个单词首字母大写</p><p>常量名：所有字母大写 ，多单词时每个单词用下划线连接</p><h2 id="四）注意"><a href="#四）注意" class="headerlink" title="四）注意"></a>四）注意</h2><p>在起名字时，为了提高阅读性，尽量要有意义</p><p>Java采用unicode字符集，标识符可以用汉字声明，但是不啊建议</p><h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h2 id="一）概念"><a href="#一）概念" class="headerlink" title="一）概念"></a>一）概念</h2><p>内存中的一个存储区域</p><p>该区域的数据可以在同一类型范围内不断变化</p><p>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</p><h2 id="二）变量的作用"><a href="#二）变量的作用" class="headerlink" title="二）变量的作用"></a>二）变量的作用</h2><p>用于在内存中保存数据</p><h2 id="三）使用变量注意"><a href="#三）使用变量注意" class="headerlink" title="三）使用变量注意"></a>三）使用变量注意</h2><p>Java中每个变量必须先声明，后使用</p><p>使用变量 名来访问这块区域的数据</p><p>变量的作用域：其定义所在的一对{}内</p><p>变量只有在其作用域内才有效</p><p>同一个作用域内，不能定义重名的变量</p><h2 id="四）变量的使用"><a href="#四）变量的使用" class="headerlink" title="四）变量的使用"></a>四）变量的使用</h2><p>Java定义变量的格式：数据类型 变量名 = 变量值</p><p>变量必须先声明后使用</p><p>变量都定义在其作用域内。在作用域内有效。</p><p>同一个作用域内，不可以声明两个同名的变量</p><h2 id="五）变量的分类"><a href="#五）变量的分类" class="headerlink" title="五）变量的分类"></a>五）变量的分类</h2><h3 id="1-变量按照数据类型"><a href="#1-变量按照数据类型" class="headerlink" title="1.变量按照数据类型"></a>1.变量按照数据类型</h3><h4 id="1-1基本数据类型"><a href="#1-1基本数据类型" class="headerlink" title="1.1基本数据类型"></a>1.1基本数据类型</h4><h5 id="数值型（整数byte-1个字节、short-2个字节、int-4个字节、long-8个字节-浮点数float-4字节、double-8字节）"><a href="#数值型（整数byte-1个字节、short-2个字节、int-4个字节、long-8个字节-浮点数float-4字节、double-8字节）" class="headerlink" title="数值型（整数byte-1个字节、short-2个字节、int-4个字节、long-8个字节+浮点数float-4字节、double-8字节）"></a>数值型（整数byte-1个字节、short-2个字节、int-4个字节、long-8个字节+浮点数float-4字节、double-8字节）</h5><p>Java各整数类型有固定的表示范围和字段长度，不受具体的os的影响，以保证Java程序的可移植性</p><p>Java的整型常量默认为int，声明long型常量后需加’l‘或’L‘</p><p>Java程序中变量通常声明为int型，除非不能表示较大的数，才使用long</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 <strong>-128（-2^7）</strong>；</li><li>最大值是 <strong>127（2^7-1）</strong>；</li><li>默认值是 <strong>0</strong>；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong>；</li><li>最大值是 <strong>32767（2^15 - 1）</strong>；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 <strong>0</strong>；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 <strong>0</strong> ；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 <strong>0L</strong>；</li><li>例子： long a = 100000L，Long b = -200000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li></ul><p><strong>float：</strong>单精度</p><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>float表示数值的范围比long还大</li><li>默认值是 <strong>0.0f</strong>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p><strong>double：双精度</strong></p><ul><li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 <strong>0.0d</strong>；</li><li>例子：double d1 = 123.4。</li></ul><h5 id="字符型char"><a href="#字符型char" class="headerlink" title="字符型char"></a>字符型char</h5><p> 用来表示通常意义上的字符-2字节</p><p>一个字符可以存储一个字母，一个汉字，或其他一个字符</p><p>字符型变量的三种表现形式</p><p>1.’’</p><p>2.允许使用转义符’\‘将其后的字符变为特殊字符型常量</p><p>3.直接使用Unicode值来表示字符型常量。\u000a表示\n</p><p>char类型均可进行运算</p><h5 id="布尔型boolean"><a href="#布尔型boolean" class="headerlink" title="布尔型boolean"></a>布尔型boolean</h5><p>只有两个值，true false</p><p>常常在条件判断和循环结构中使用</p><h4 id="1-2引用数据类型"><a href="#1-2引用数据类型" class="headerlink" title="1.2引用数据类型"></a>1.2引用数据类型</h4><p>类class(字符串)</p><p>接口interface</p><p>数组[ ]</p><h3 id="2-变量按照声明的位置分类"><a href="#2-变量按照声明的位置分类" class="headerlink" title="2.变量按照声明的位置分类"></a>2.变量按照声明的位置分类</h3><p>成员变量</p><p>局部变量 </p><h2 id="六）基本数据之间的-运算规则（除了布尔类型）"><a href="#六）基本数据之间的-运算规则（除了布尔类型）" class="headerlink" title="六）基本数据之间的 运算规则（除了布尔类型）"></a>六）基本数据之间的 运算规则（除了布尔类型）</h2><p>小转大自动，大转小强制</p><h3 id="1-自动类型提升"><a href="#1-自动类型提升" class="headerlink" title="1.自动类型提升"></a>1.自动类型提升</h3><p>容量小的数据类型变量与容量大的数据类型的变量做运算时，结果自动提升为大容量的数据类型（容量大小指的是表示数的范围大和小）</p><p>byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double</p><p>特别的，当byte、char、short三种类型的变量做运算时，结果为int型</p><h3 id="2-强制类型转化"><a href="#2-强制类型转化" class="headerlink" title="2.强制类型转化"></a>2.强制类型转化</h3><p>自动提升运算的逆运算</p><p>1.需要使用强转符（）</p><p>2.注意：强制类型转换，可能导致精度损失</p><h3 id="3-两个特殊情况"><a href="#3-两个特殊情况" class="headerlink" title="3.两个特殊情况"></a>3.两个特殊情况</h3><p>1.编码情况</p><p>要编译long型，数字后边必须增加l；编译float，必须加f</p><p>2.编译情况2</p><p>整型常量，默认为int型；浮点型常量，默认类型为double型</p><h2 id="七）字符串类型：String"><a href="#七）字符串类型：String" class="headerlink" title="七）字符串类型：String"></a>七）字符串类型：String</h2><p>String不是基本数据类型，属于引用数据类型</p><p>声明string类型变量时，使用 “ ”（必须用双引号嗷）</p><p>string可以和8种数据类型变量做运算，且运算只能是连接运算+</p><h2 id="八）进制与进制之间的转化"><a href="#八）进制与进制之间的转化" class="headerlink" title="八）进制与进制之间的转化"></a>八）进制与进制之间的转化</h2><p>所有数字在计算机底层都以二进制形式存在</p><p>整数有四种表示方式：二进制、十进制、八进制、十六进制</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二天——1.Java语言概述</title>
    <link href="/2021/01/16/%E7%AC%AC%E4%BA%8C%E5%A4%A9%E2%80%94%E2%80%941.Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/01/16/%E7%AC%AC%E4%BA%8C%E5%A4%A9%E2%80%94%E2%80%941.Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="C:\Users\贺昕贺昕贺昕呀\Desktop\IMG_2901.PNG" alt="IMG_2901"></p><h1 id="一、软件开发介绍"><a href="#一、软件开发介绍" class="headerlink" title="一、软件开发介绍"></a>一、软件开发介绍</h1><h2 id="一）介绍"><a href="#一）介绍" class="headerlink" title="一）介绍"></a>一）介绍</h2><h3 id="1-软件，一系列按照特定顺序组织计算机数据和指令的集合。系统软件-应用软件"><a href="#1-软件，一系列按照特定顺序组织计算机数据和指令的集合。系统软件-应用软件" class="headerlink" title="1.软件，一系列按照特定顺序组织计算机数据和指令的集合。系统软件+应用软件"></a>1.软件，一系列按照特定顺序组织计算机数据和指令的集合。系统软件+应用软件</h3><h3 id="2-人机交互方式"><a href="#2-人机交互方式" class="headerlink" title="2.人机交互方式"></a>2.人机交互方式</h3><p>图形化界面GUI，graphical user interfaces</p><p>命令行方式CLI，command line interface</p><h3 id="3-program-algorithms-data-structuress"><a href="#3-program-algorithms-data-structuress" class="headerlink" title="3.program = algorithms + data structuress"></a>3.program = algorithms + data structuress</h3><h3 id="4-注，常见DOS指令"><a href="#4-注，常见DOS指令" class="headerlink" title="4.注，常见DOS指令"></a>4.注，常见DOS指令</h3><p>dir：列出当前目录下的文件以及文件夹</p><p>md：创建目录</p><p>rd：删除目录</p><p>cd：进入指定目录</p><p>cd..：退回到上一级目录</p><p>cd\：退回到根目录</p><p>del：删除文件</p><p>exit：推出dos命令</p><h2 id="二）计算机编程语言介绍"><a href="#二）计算机编程语言介绍" class="headerlink" title="二）计算机编程语言介绍"></a>二）计算机编程语言介绍</h2><h3 id="1-语言更新"><a href="#1-语言更新" class="headerlink" title="1.语言更新"></a>1.语言更新</h3><p>第一代语言，机器语言。指令以二进制代码形式存在</p><p>第二代语言，汇编语言。使用助记符表示一条机器指令</p><p>第三代语言，高级语言。c，面向对象。c++，面向过程/面向对象。java跨平台的纯面向对象的语言。.net跨语言的平台。python</p><h3 id="2-Java"><a href="#2-Java" class="headerlink" title="2.Java"></a>2.Java</h3><p>发展前景很好，目前占比很大</p><h2 id="三）Java语言概述"><a href="#三）Java语言概述" class="headerlink" title="三）Java语言概述"></a>三）Java语言概述</h2><h3 id="1-Java历史"><a href="#1-Java历史" class="headerlink" title="1.Java历史"></a>1.Java历史</h3><p>sun公司推出（斯坦福大学网络公司）。面向Internet的编程语言。web应用程序开发首选语言</p><p>后台开发：Java、php、python、go、node.js</p><h3 id="2-Java在各个领域的应用"><a href="#2-Java在各个领域的应用" class="headerlink" title="2.Java在各个领域的应用"></a>2.Java在各个领域的应用</h3><p>企业及平台（主）</p><p>Android平台应用（主）</p><p>大数据平台开发（主）</p><p>移动领域应用</p><h3 id="3-Java语言的诞生"><a href="#3-Java语言的诞生" class="headerlink" title="3.Java语言的诞生"></a>3.Java语言的诞生</h3><p>纯粹的面向对象</p><p>舍弃了C容易引起错误的指针</p><p>增加了垃圾回收器功能</p><h2 id="四）Java程序运行机制及运行过程"><a href="#四）Java程序运行机制及运行过程" class="headerlink" title="四）Java程序运行机制及运行过程"></a>四）Java程序运行机制及运行过程</h2><h3 id="1-Java语言的特点"><a href="#1-Java语言的特点" class="headerlink" title="1.Java语言的特点"></a>1.Java语言的特点</h3><p>面向对象（类+对象；封装+继承+多态）</p><p>健壮性（没有指针之类的）</p><p>跨平台性（不同平台都可以运行，write once，run anywhere，因为有JVM）</p><h3 id="2-Java的核心机制"><a href="#2-Java的核心机制" class="headerlink" title="2.Java的核心机制"></a>2.Java的核心机制</h3><p>Java虚拟机（Jvm）</p><p>垃圾收集机制（自动执行，程序员无法精确控制和干预。也会出现内存泄漏和内存溢出等问题）</p><h3 id="3-注释（comment）"><a href="#3-注释（comment）" class="headerlink" title="3.注释（comment）"></a>3.注释（comment）</h3><p>（注释和注解不一样，①一定要加注释，否则过一段时间自己的也不会了②调试所写的代码）</p><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><p>//</p><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><p>/*   */      弹幕说每一行之前都要加一个星号</p><p>多行注释不可以嵌套使用</p><p>但是多行里边可以加单行，虽然没有什么用</p><h4 id="文档注释-java所特有"><a href="#文档注释-java所特有" class="headerlink" title="文档注释 (java所特有)"></a>文档注释 (java所特有)</h4><p>/**          @author 指定Java程序的作者  @version  指定源文件的版本            */  </p><p>文档注释内容可以被jdk提供的工具javadc所解析，可以形成一个网页用来浏览。</p><h2 id="五）Java-API文档"><a href="#五）Java-API文档" class="headerlink" title="五）Java API文档"></a>五）Java API文档</h2><p>就是字典的意思</p><h1 id="二、第一个Java程序总结"><a href="#二、第一个Java程序总结" class="headerlink" title="二、第一个Java程序总结"></a>二、第一个Java程序总结</h1><h2 id="一）Java程序编写-编译-运行的结果"><a href="#一）Java程序编写-编译-运行的结果" class="headerlink" title="一）Java程序编写-编译-运行的结果"></a>一）Java程序编写-编译-运行的结果</h2><p>编写：我们将编写的Java代码保存在以“.java”结尾的源文件中</p><p>编译：使用javac.exe命令编译我们的Java源文件</p><p>运行：使用java.exe命令解释运行我们的字节码文件</p><h2 id="二）编写过程"><a href="#二）编写过程" class="headerlink" title="二）编写过程"></a>二）编写过程</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>在一个java源文件中可以有多个类，但是只能最多有一个类的声明 为public</p><p>要求声明为public的类的类名必须与源文件同名</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>程序的入口是main（）方法。格式是固定的</p><h3 id="4-输出语句"><a href="#4-输出语句" class="headerlink" title="4.输出语句"></a>4.输出语句</h3><p>syetem.out.println()换行，先输出数据后换行</p><p>syetem.out.print()不换行，只输出数据，不换行</p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>每一次的执行语句都以；结束</p><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><p>使用tab进行缩进</p><h2 id="三）编译过程"><a href="#三）编译过程" class="headerlink" title="三）编译过程"></a>三）编译过程</h2><p>编译以后，会生成一个或多个字节码文件。字节码文件（.class）的文件名与Java源文件(.java)中的类名相同</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一天——1.Java准备基础知识</title>
    <link href="/2021/01/14/%E7%AC%AC%E4%B8%80%E5%A4%A9%E2%80%94%E2%80%941.Java%E5%87%86%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/01/14/%E7%AC%AC%E4%B8%80%E5%A4%A9%E2%80%94%E2%80%941.Java%E5%87%86%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>第一天，安装了环境和编译器</p><h1 id="关于Java环境基础了解"><a href="#关于Java环境基础了解" class="headerlink" title="关于Java环境基础了解"></a>关于Java环境基础了解</h1><h2 id="关于Java"><a href="#关于Java" class="headerlink" title="关于Java"></a>关于Java</h2><p>Java是一门面向对象的程序设计语言</p><p>JDK版本是8.0</p><p>Java SE，Java标准版（桌面程序）；Java EE，Java企业版（Web程序）；Java ME，Java微型版（移动设备）；Java Card（Java小程序在小内存设备上的平台）</p><h2 id="关于JVM"><a href="#关于JVM" class="headerlink" title="关于JVM"></a>关于JVM</h2><p>Java Virtual Machine，Java虚拟机</p><p>实现Java平台无关性的关键</p><h2 id="关于JDK"><a href="#关于JDK" class="headerlink" title="关于JDK"></a>关于JDK</h2><p>Java development Kit，Java语言的软件开发工具包</p><p>由javac和Java组成（javac，编译器将原程序转化为字节码；Java，运行编译后的Java程序，后缀为.class）</p><h2 id="关于JRE"><a href="#关于JRE" class="headerlink" title="关于JRE"></a>关于JRE</h2><p>Java Runtime Environment = vm(java虚拟机) + Java核心类库 + 支持文件</p><p>JDK面向开发人员（开发Java软件要用），JRE面向使用人员（使用Java软件要用）</p><p>JVM&lt;JRE&lt;JDK(包含关系)</p>]]></content>
    
    
    <categories>
      
      <category>back-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+GitHub搭建个人博客页面</title>
    <link href="/2021/01/12/hexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/01/12/hexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、一堆乱七八糟的废话"><a href="#一、一堆乱七八糟的废话" class="headerlink" title="一、一堆乱七八糟的废话"></a>一、一堆乱七八糟的废话</h1><p>关于选择个人博客页面是因为很久之前就在B站上看过好多up主的视频，大多数的标题都是10分钟，20分钟，小白搞定个人博客。反正就是很吸引人，然后19年过年的时候，看到了一名华侨大学学长的个人博客，他当时发表的文章是学爬虫的时候做的笔记。那个时候也尝试弄过一段时间，没搞对，有着这样那样的很多的问题然后就放弃了。今年1月3号回的家，想起来这茬事。</p><p>期间还重装了几次电脑，我的电脑什么时候可以起飞，配环境啥的简直太恐怖了。装的时候很费事，搞清楚顺序还有其中的关系就很快了。</p><p>关于为什么要选择hexo+GitHub进行搭建，也没什么原因，就是因为网上都是这么说的，都说这么搞十分钟就搞好了</p><h1 id="二、安装环境配置等一系列准备"><a href="#二、安装环境配置等一系列准备" class="headerlink" title="二、安装环境配置等一系列准备"></a>二、安装环境配置等一系列准备</h1><p>1.git bash</p><p>2.node.js</p><p>3.hexo</p><h2 id="关于git-bash"><a href="#关于git-bash" class="headerlink" title="关于git bash"></a>关于git bash</h2><p>git bash其实就是相当于自带的cmd，可以直接在某个文件夹里Git Bash Here用了几次之后觉得非常方便。我是在这里下载的</p><p><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>用的Google浏览器，自带的翻译，看不懂就翻译，看不懂就翻译，大部分是看不懂的。</p><h2 id="关于Node-js"><a href="#关于Node-js" class="headerlink" title="关于Node.js"></a>关于Node.js</h2><p>NodeJS是hexo的环境，后续了解到下载这个环境是为了使用npm工具，后续好多都需要npm，瑞斯拜</p><p>下载地址<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>我下载的是LTS版本的</p><h2 id="关于hexo"><a href="#关于hexo" class="headerlink" title="关于hexo"></a>关于hexo</h2><p>终于到hexo了</p><p>首先，安装npm，win+R打开cmd一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>然后，等安装完之后。检查一下node，npm是否安装成功。继续cmd一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><p>接着，在要存博客的位置新建一个文件夹，我给自己的命名的是myblog，存在了D盘。打开D盘，右击myblog，选择Git Bash Here，会弹出一个类似cmd，但是是彩色的黑色框框。之后在里边输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init    <span class="hljs-comment">#初始化</span><br>npm install<br></code></pre></td></tr></table></figure><p>这样，就算全部安装完成了。</p><h1 id="三、打开最开始的hexo"><a href="#三、打开最开始的hexo" class="headerlink" title="三、打开最开始的hexo"></a>三、打开最开始的hexo</h1><p>上述完成之后，相当于最初的安装已经全部完成。接下来，就是网站的编译发布。还是myblog右击点开Git Bash Here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><p>上述两步完成之后，在浏览器输入<a href="http://localhost:4000，便可以访问刚刚搞好的hexo首页，这个是原始的那种，不过还是很好看。">http://localhost:4000，便可以访问刚刚搞好的hexo首页，这个是原始的那种，不过还是很好看。</a></p><h1 id="四、部署到GitHub上"><a href="#四、部署到GitHub上" class="headerlink" title="四、部署到GitHub上"></a>四、部署到GitHub上</h1><h2 id="第一步。GitHub注册且建仓库"><a href="#第一步。GitHub注册且建仓库" class="headerlink" title="第一步。GitHub注册且建仓库"></a>第一步。GitHub注册且建仓库</h2><p>需要一个GitHub账号，然后新建一个库，名字就是自己GitHub的名+github.io(我也不知道为什么要这么命名，但是大家都是这么教的，好像是因为后续好通过域名进入)。</p><p>这一步的话，最好看一看自己能不能使用GitHub Pages。（我的就是不能用，全都弄完才发现打不开还以为是电脑坏了，后来才发现是因为我家的路由器的问题。）我是根据CSDN上的文章，修改了DNS服务器的地址，改成了114 .114.114.114,后续就可使用了。可以参照<a href="https://blog.csdn.net/wuufeii/article/details/108151697">https://blog.csdn.net/wuufeii/article/details/108151697</a></p><h2 id="第二步。和GitHub账户相关联"><a href="#第二步。和GitHub账户相关联" class="headerlink" title="第二步。和GitHub账户相关联"></a>第二步。和GitHub账户相关联</h2><p>之后，就是很重要的这个联网，我也不知道我为什么搞了很久。还是右击mylog，Git Bash Here。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的GitHub用户名&quot;</span> <br>git config --global user.email <span class="hljs-string">&quot;你GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>检验是否设置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure><p>之后改变站点的配置信息，打开myblog文件夹，找到 _config.yml文件，使用笔记本或者vscode等各种编译器打开修改最后的几行，保存退出。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">deploy:</span>  <br><span class="hljs-attr">type:</span> git  <br><span class="hljs-attr">repo:</span> <span class="hljs-attr">https:</span><span class="hljs-comment">//github.com/YourgithubName/YourgithubName.github.io.git  （这个网址是你GitHub仓库的地址，从GitHub中复制黏贴过去）</span><br><span class="hljs-attr">branch:</span> master<br></code></pre></td></tr></table></figure><h2 id="第三步。创建ssh"><a href="#第三步。创建ssh" class="headerlink" title="第三步。创建ssh"></a>第三步。创建ssh</h2><p>创建ssh的目的应该是为了方便后续将文件部署至git，更加方便快捷。</p><p>右击myblog使用Bash，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;你自己的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>我后续都是一直回车的，他有设置用户名密码啥的，我主要是怕密码忘记，就全按默认回车了。有一个方框框的那种图形的显示，就是创建成功了。之后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/.ssh<br>ls<br></code></pre></td></tr></table></figure><p>查看。如果显示is adirectory，就是说明文件存在了。根据文件路径找到.ssh，用记事本打开id_rsa.pub，将里边内容全部复制。</p><p>之后添加ssh key到GitHub，在git中打开个人用户那里的settings，里边有个SSH keys，点击new SSH keys。title随便写，key复制刚刚的内容。保存。</p><p>会有一段时间，隔一段时间再bash，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>出现问题的时候回复yes，之后有个hi，你自己的用户名，You’ve successfully authenticated, but GitHub does not provide shell access.就表示已经设置成功。</p><h2 id="第四步。安装git的扩展包，就是将hexo部署到git上"><a href="#第四步。安装git的扩展包，就是将hexo部署到git上" class="headerlink" title="第四步。安装git的扩展包，就是将hexo部署到git上"></a>第四步。安装git的扩展包，就是将hexo部署到git上</h2><p>继续Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>安装完成之后，继续bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><p>如果显示info deploy done：git说明就是部署成功了。如果不成功的话，会给你发邮件页面打不开，很显然邮件内容是全英文的o(TヘTo)。主题是Page build warning。</p><p>成功的话使用用户名.github.io便可以打开，和刚刚本地浏览的一样。</p><h1 id="五、更换域名"><a href="#五、更换域名" class="headerlink" title="五、更换域名"></a>五、更换域名</h1><p>如果想要自己的域名，可以购买一个，之后进行备案就可以用，在仓库里修改就可以使用了。（今天刚接到阿里小哥哥的电话，我可能快能用到自己掏钱买的域名辽。）</p><h1 id="六、关于怎么用"><a href="#六、关于怎么用" class="headerlink" title="六、关于怎么用"></a>六、关于怎么用</h1><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>关于怎么用我也没有搞太对，还不了解，昨天更换了一个主题，在别人的git上down下来主题，之后修改一些图片之类的参数，改成自己更加喜欢的样式。我使用的是fluid。这个主题真的巨好用，里边很多样式我都巨喜欢。</p><p>改图片的话，我找了半天，是要在.deploy_git里边进行修改，如果直接改public里边的，一bash就没有了</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>写文章使用的是Markdown语言，也是一种标记语言，不挺简单的，我下载了一个typora，更方便，这篇文章是我的首次尝试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;文章名称&quot;</span><br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>关于每次修改完的更新，一般使用如下三个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<span class="hljs-comment">#清除缓存</span><br><br>hexo g<span class="hljs-comment">#编译</span><br><br>hexo d<span class="hljs-comment">#部署到git</span><br><br>hexo s<span class="hljs-comment">#在本地进行服务，可以使用http://localhost:4000/打开。</span><br></code></pre></td></tr></table></figure><p>大概就是这样，然后就是看看我这篇文章能否顺利上传。</p>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/10/hello-world/"/>
    <url>/2021/01/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to hexin‘blog! This is your very first post. 这是hexo搭成后的第一个blog，舍不得删除，改一改就这样留着哇。</p><p>hello world</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
